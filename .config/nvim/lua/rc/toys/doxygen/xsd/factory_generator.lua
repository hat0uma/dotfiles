--- Find simple type by name
---@param schema Xsd.Schema
---@param name string
---@return Xsd.SimpleType
local function find_simple_type(schema, name)
  for _, simple_type in ipairs(schema.simple_types) do
    if simple_type.name == name then
      return simple_type
    end
  end
  error("simple type not found: " .. name)
end

---@class DoxygenFactoryGenerator
---@field opts DoxygenGeneratorOpts
local DoxygenFactoryGenerator = {}

--- Create a new DoxygenFactoryGenerator.
---@param opts DoxygenGeneratorOpts
---@return DoxygenFactoryGenerator
function DoxygenFactoryGenerator:new(opts)
  local obj = {}
  obj.opts = opts
  setmetatable(obj, self)
  self.__index = self
  return obj
end

--- Generate factory from schema
---@param schema Xsd.Schema
---@return string[]
function DoxygenFactoryGenerator:generate(schema)
  local out_lines = {}
  local function emit(line)
    table.insert(out_lines, line)
  end
  local function emitf(fmt, ...)
    emit(string.format(fmt, ...))
  end

  local function start_factory(type)
    emitf("--- @param builder eeeBuilder")
    emitf("--- @return %s", self:_qualified(type))
    emitf("function factory.%s(builder)", type)
  end

  local function end_factory()
    emit("end")
    emit("")
  end

  emit("--")
  emit("-- GENERATED BY factory_generator.lua")
  emit("--")
  emit("local factory = {}")

  start_factory("string")
  emit("  return builder:from_text()")
  end_factory()

  emit("--------------------------------")
  emit("-- Complex Types")
  emit("--------------------------------")
  for _, complex_type in ipairs(schema.complex_types) do
    if vim.tbl_contains(self.opts.text_foldings, complex_type.name) then
      start_factory(complex_type.name)
      emit("  return builder:from_folded_text_content()")
      end_factory()
    elseif complex_type.mixed then
      start_factory(complex_type.name)
      emitf("  return{ --- @type %s", self:_qualified(complex_type.name))
      emitf("    %s = builder:from_element_mixed(),", "content") -- TODO
      for _, current in ipairs(complex_type.content) do
        if current.kind == "attribute" then
          local type = self:_t(current.type)
          local basetypes = {
            boolean = "boolean",
            string = "string",
            number = "number",
            integer = "number",
          }

          emitf(
            '    ["%s"] = builder:from_attr("%s","%s","%s"),',
            self:_v(current.name),
            current.name,
            current.occurs,
            basetypes[type] and basetypes[type] or find_simple_type(schema, current.type).base
          )
        end
      end
      emitf("  }")
      end_factory()
    else
      start_factory(complex_type.name)
      emitf("  return{ --- @type %s", self:_qualified(complex_type.name))
      emit(self:_generate_content_fields(schema, complex_type))
      emitf("  }")
      end_factory()
    end
  end

  emit("--------------------------------")
  emit("-- Groups")
  emit("--------------------------------")
  for _, group in ipairs(schema.groups) do
    emitf("--- @param builder eeeBuilder")
    emitf("--- @return %s", self:_qualified(group.name))
    emitf("function factory.%s(builder)", group.name)
    emitf("  return{ --- @type %s", self:_qualified(group.name))
    emit(self:_generate_content_fields(schema, group))
    emitf("  }")
    emitf("end")
  end

  emit("return factory")
  return out_lines
end

---@param schema Xsd.Schema
---@param element Xsd.ComplexType | Xsd.Group
---@return string
function DoxygenFactoryGenerator:_generate_content_fields(schema, element)
  local out_lines = {}
  local function emit(line)
    table.insert(out_lines, line)
  end
  local function emitf(fmt, ...)
    emit(string.format(fmt, ...))
  end
  local stack = {} ---@type (Xsd.Content|fun())[]
  local function push_to_stack(content) ---@param content Xsd.Content[]
    for i = #content, 1, -1 do
      table.insert(stack, content[i])
    end
  end

  push_to_stack(element.content)
  while #stack > 0 do
    local current = table.remove(stack) ---@type Xsd.Content|fun()
    if type(current) == "function" then
      current()
    elseif current.kind == "sequence" then
      push_to_stack(current.content)
    elseif current.kind == "choice" then
      emitf('    ["%s"] = builder:choice(%s),', "choice", self:_generate_choice(current))
    elseif current.kind == "group" then
      emitf('    ["%s"] = builder:from_group(factory.%s),', "group", current.ref)
    elseif current.kind == "attribute" then
      local type = self:_t(current.type)
      local basetypes = {
        boolean = "boolean",
        string = "string",
        number = "number",
        integer = "number",
      }
      emitf(
        '    ["%s"] = builder:from_attr("%s","%s","%s"),',
        self:_v(current.name),
        current.name,
        current.occurs,
        basetypes[type] and basetypes[type] or find_simple_type(schema, current.type).base
      )
    elseif current.kind == "element" then
      emitf(
        '    ["%s"] = builder:from_element("%s","%s",factory.%s),',
        self:_v(current.name),
        current.name,
        current.occurs,
        self:_t(current.type)
      )
    elseif current.kind == "text-only-element" then
      emitf(
        '    ["%s"] = builder:from_text_only_element("%s","%s"),',
        self:_v(current.name),
        current.name,
        current.occurs
      )
    elseif current.kind == "text" then
      emitf('    ["%s"] = builder:from_text(),', "text")
    else
      error("unexpected content: " .. vim.inspect(current))
    end
  end
  emit("")

  return table.concat(out_lines, "\n")
end
---
---@param choice Xsd.Choice
---@return string
function DoxygenFactoryGenerator:_generate_choice(choice)
  local type = {}
  local stack = {}
  for i = #choice.content, 1, -1 do
    table.insert(stack, choice.content[i])
  end

  while #stack > 0 do
    local current = table.remove(stack) ---@type Xsd.Content|fun()
    if current.kind == "element" then
      table.insert(
        type,
        string.format(
          '{ name = "%s", factory = factory.%s, occurence="%s" },',
          self:_v(current.name),
          self:_t(current.type),
          current.occurs
        )
      )
    else
      error("unexpected content: " .. vim.inspect(current))
    end
  end

  return "{" .. table.concat(type, "\n") .. "}"
end

--- Convert type
---@param type string
---@param occurence? Xsd.ContentOccur
---@return string
function DoxygenFactoryGenerator:_t(type, occurence)
  local suffixes = {
    array = "[]",
    optional = "?",
  }
  local body = self.opts.type_mappings[type] or type
  local suffix = suffixes[occurence] or ""
  return body .. suffix
end

--- Convert name
---@param name string
---@return string
function DoxygenFactoryGenerator:_v(name)
  if self.opts.name_converter then
    return self.opts.name_converter(name)
  end

  return name
end

--- Qualified type
---@param type string
---@return string
function DoxygenFactoryGenerator:_qualified(type)
  if self.opts.namespace and not self.opts.type_mappings[type] then
    return string.format("%s.%s", self.opts.namespace, type)
  else
    return type
  end
end

return DoxygenFactoryGenerator
