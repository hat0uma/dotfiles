-- Utility: push elements of a list onto a stack in reverse order
local function push_to_stack(stack, list)
  for i = #list, 1, -1 do
    table.insert(stack, list[i])
  end
end

---@class DoxygenTypeGenerator
---@field opts DoxygenGeneratorOpts
local DoxygenTypeGenerator = {}

--- Create a new DoxygenTypeGenerator.
---@param opts DoxygenGeneratorOpts
---@return DoxygenTypeGenerator
function DoxygenTypeGenerator:new(opts)
  local obj = {}
  obj.opts = opts

  setmetatable(obj, self)
  self.__index = self
  return obj
end

--- Generate types from schema
---@param schema Xsd.Schema
---@return string[]
function DoxygenTypeGenerator:generate(schema)
  local lines = {}
  local function emit(line)
    table.insert(lines, line)
  end
  local function emitf(fmt, ...)
    emit(string.format(fmt, ...))
  end

  -- File header
  emit("--")
  emit("-- GENERATED BY type_generator.lua")
  emit("--")

  emit("--------------------------------")
  emit("-- Simple Types")
  emit("--------------------------------")
  for _, simple_type in ipairs(schema.simple_types) do
    if not self.opts.type_mappings[simple_type.name] then
      if simple_type.kind == "enumeration" then
        emitf("---@alias %s", self:_t(simple_type.name))
        for _, enum in ipairs(simple_type.enumerations) do
          emitf('---| "%s"', enum)
        end
      elseif simple_type.kind == "pattern" then
        emitf("---@alias %s string (pattern: %s)", self:_t(simple_type.name), simple_type.pattern)
      elseif simple_type.kind == "range" then
        local range = self:_render_range(simple_type.min, simple_type.max)
        emitf("---@alias %s number (range: %s)", self:_t(simple_type.name), range)
      else
        error("unexpected simple type: " .. vim.inspect(simple_type))
      end
      emit("")
    end
  end

  emit("--------------------------------")
  emit("-- Complex Types")
  emit("--------------------------------")
  for _, complex_type in ipairs(schema.complex_types) do
    if vim.tbl_contains(self.opts.text_foldings, complex_type.name) then
      emitf("---@alias %s string[] (folded text)", self:_t(complex_type.name))
      emit("")
    elseif complex_type.mixed then
      emit(self:_generate_mixed(complex_type))
    else
      emitf("---@class %s", self:_t(complex_type.name))
      emit(self:_generate_content_fields(complex_type))
    end
    emit("")
  end

  emit("--------------------------------")
  emit("-- Groups")
  emit("--------------------------------")
  for _, group in ipairs(schema.groups) do
    emitf("---@class %s", self:_t(group.name))
    emit(self:_generate_content_fields(group))
    emit("")
  end

  return lines
end

--- Qualified type
---@param type string
---@return string
function DoxygenTypeGenerator:_qualified(type)
  if self.opts.namespace and not self.opts.type_mappings[type] then
    return string.format("%s.%s", self.opts.namespace, type)
  else
    return type
  end
end

---
---@param complex_type Xsd.ComplexType
---@return string
function DoxygenTypeGenerator:_generate_mixed(complex_type)
  local lines = {}
  local function emit(line)
    table.insert(lines, line)
  end
  local function emitf(fmt, ...)
    emit(string.format(fmt, ...))
  end

  local stack = {}
  push_to_stack(stack, complex_type.content)

  -- Emit class definition and attribute fields first
  emitf("---@class %s (mixed)", self:_t(complex_type.name))
  for _, content in ipairs(complex_type.content) do
    if content.kind == "attribute" then
      emitf("---@field %s %s (attribute)", self:_v(content.name), self:_t(content.type, content.occurs))
    end
  end

  emitf("---@field content %s", self:_t(complex_type.name))
  emitf("---| string (text content)")

  while #stack > 0 do
    local current = table.remove(stack)
    if current.kind == "attribute" then
      -- Attributes already emitted; skip.
      local _ = nil
    elseif current.kind == "element" then
      emitf('---| { name: "%s", value: %s }', self:_v(current.name), self:_t(current.type, current.occurs))
    elseif current.kind == "sequence" or current.kind == "choice" then
      push_to_stack(stack, current.content)
    elseif current.kind == "group" then
      emitf('---| { name: "%s", value: %s }', "group", self:_t(current.ref, current.occurs))
    elseif current.kind == "text-only-element" then
      error("text-only-element not supported: " .. vim.inspect(current))
    elseif current.kind == "text" then
      error("text content not supported: " .. vim.inspect(current))
    else
      error("unexpected content in mixed: " .. vim.inspect(current))
    end
  end

  return table.concat(lines, "\n")
end

---@param element Xsd.ComplexType | Xsd.Group
---@return string
function DoxygenTypeGenerator:_generate_content_fields(element)
  local lines = {}
  local function emit(line)
    table.insert(lines, line)
  end
  local function emitf(fmt, ...)
    emit(string.format(fmt, ...))
  end

  local stack = {} ---@type (Xsd.Content|fun())[]
  push_to_stack(stack, element.content)

  while #stack > 0 do
    local current = table.remove(stack)
    if type(current) == "function" then
      current()
    elseif current.kind == "sequence" then
      emit("--- start sequence")
      table.insert(stack, function()
        emit("--- end sequence")
      end)
      push_to_stack(stack, current.content)
    elseif current.kind == "choice" then
      emitf("---@field %s", "choice")
      emitf("---| %s", self:_generate_choice(current))
    elseif current.kind == "group" then
      emitf("---@field %s %s", "group", self:_t(current.ref))
    elseif current.kind == "attribute" then
      emitf("---@field %s %s (attribute)", self:_v(current.name), self:_t(current.type, current.occurs))
    elseif current.kind == "element" then
      emitf("---@field %s %s (element)", self:_v(current.name), self:_t(current.type, current.occurs))
    elseif current.kind == "text-only-element" then
      emitf("---@field %s %s (text-only-element)", self:_v(current.name), self:_t(current.type, current.occurs))
    elseif current.kind == "text" then
      emitf("---@field %s %s (text content)", "text", self:_t(current.type))
    else
      error("unexpected content in fields: " .. vim.inspect(current))
    end
  end
  emit("")

  return table.concat(lines, "\n")
end

---@param choice Xsd.Choice
---@return string
function DoxygenTypeGenerator:_generate_choice(choice)
  local elements = {}
  -- Process each element in order
  for _, content in ipairs(choice.content) do
    if content.kind == "element" then
      local type =
        string.format('{ name: "%s", value: %s }', self:_v(content.name), self:_t(content.type, content.occurs))
      table.insert(elements, type)
    else
      error("unexpected content in choice: " .. vim.inspect(content))
    end
  end
  return table.concat(elements, "\n---| ")
end

--- Convert XSD type name to Lua type name
---@param type_name string
---@param occurrence? Xsd.ContentOccur
---@return string
function DoxygenTypeGenerator:_t(type_name, occurrence)
  local suffixes = {
    array = "[]",
    optional = "?",
  }
  local body = self.opts.type_mappings[type_name] or self:_qualified(type_name)
  local suffix = suffixes[occurrence] or ""
  return body .. suffix
end

--- Convert name
---@param name string
---@return string
function DoxygenTypeGenerator:_v(name)
  if self.opts.name_converter then
    return self.opts.name_converter(name)
  end

  return name
end

--- Render a range
---@param min? { value: number, inclusive: boolean }
---@param max? { value: number, inclusive: boolean }
---@return string
function DoxygenTypeGenerator:_render_range(min, max)
  local min_value = min and min.value or ""
  local max_value = max and max.value or ""
  local min_symbol = min and (min.inclusive and "<=" or "<") or ""
  local max_symbol = max and (max.inclusive and "<=" or "<") or ""
  return string.format("%s%sx%s%s", min_value, min_symbol, max_symbol, max_value)
end

return DoxygenTypeGenerator
