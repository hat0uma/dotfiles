-- Utility function to get the current script path
local function get_script_path()
  local source = debug.getinfo(2, "S").source:sub(2)
  return source:match("(.*/)")
end

--- Convert XSD name to Lua name
---@param name string
---@return string
local function v(name)
  return (name:gsub(":", "_"))
end

--- Convert XSD type name to Lua type name
---@param type_name string
---@param occurance? Xsd.ContentOccur
---@return string
local function t(type_name, occurance)
  local name_conversion = {
    ["xsd:string"] = "string",
    ["xsd:boolean"] = "boolean",
    ["xsd:integer"] = "integer",
    ["xsd:decimal"] = "number",
    ["DoxBool"] = "boolean",
  }
  local suffixes = {
    array = "[]",
    optional = "?",
  }
  local body = name_conversion[type_name] or type_name
  local suffix = suffixes[occurance] or ""
  return body .. suffix
end

--- Find simple type by name
---@param schema Xsd.Schema
---@param name string
---@return Xsd.SimpleType
local function find_simple_type(schema, name)
  for _, simple_type in ipairs(schema.simple_types) do
    if simple_type.name == name then
      return simple_type
    end
  end
  error("simple type not found: " .. name)
end

---
---@param choice Xsd.Choice
---@return string
local function generate_choice(choice)
  local type = {}
  local stack = {}
  for i = #choice.content, 1, -1 do
    table.insert(stack, choice.content[i])
  end

  while #stack > 0 do
    local current = table.remove(stack) ---@type Xsd.Content|fun()
    if current.kind == "element" then
      table.insert(
        type,
        string.format(
          '{ name = "%s", factory = factory.%s, occurence="%s" },',
          v(current.name),
          t(current.type),
          current.occurs
        )
      )
    else
      error("unexpected content: " .. vim.inspect(current))
    end
  end

  return "{" .. table.concat(type, "\n") .. "}"
end

---@param schema Xsd.Schema
---@param element Xsd.ComplexType | Xsd.Group
---@return string
local function generate_content_fields(schema, element)
  local out_lines = {}
  local function emit(line)
    table.insert(out_lines, line)
  end
  local function emitf(fmt, ...)
    emit(string.format(fmt, ...))
  end
  local stack = {} ---@type (Xsd.Content|fun())[]
  local function push_to_stack(content) ---@param content Xsd.Content[]
    for i = #content, 1, -1 do
      table.insert(stack, content[i])
    end
  end

  push_to_stack(element.content)
  while #stack > 0 do
    local current = table.remove(stack) ---@type Xsd.Content|fun()
    if type(current) == "function" then
      current()
    elseif current.kind == "sequence" then
      push_to_stack(current.content)
    elseif current.kind == "choice" then
      emitf('    ["%s"] = builder:choice(%s),', "choice", generate_choice(current))
    elseif current.kind == "group" then
      emitf('    ["%s"] = builder:from_group(factory.%s),', "group", current.ref)
    elseif current.kind == "attribute" then
      local type = t(current.type)
      local basetypes = {
        boolean = "boolean",
        string = "string",
        number = "number",
        integer = "number",
      }
      emitf(
        '    ["%s"] = builder:from_attr("%s","%s","%s"),',
        v(current.name),
        current.name,
        current.occurs,
        basetypes[type] and basetypes[type] or find_simple_type(schema, current.type).base
      )
    elseif current.kind == "element" then
      emitf(
        '    ["%s"] = builder:from_element("%s","%s",factory.%s),',
        v(current.name),
        current.name,
        current.occurs,
        t(current.type)
      )
    elseif current.kind == "text-only-element" then
      emitf('    ["%s"] = builder:from_text_only_element("%s","%s"),', v(current.name), current.name, current.occurs)
    elseif current.kind == "text" then
      emitf('    ["%s"] = builder:from_text(),', "text")
    else
      error("unexpected content: " .. vim.inspect(current))
    end
  end
  emit("")

  return table.concat(out_lines, "\n")
end

--- Generate types from schema
---@param schema Xsd.Schema
---@param namespace string
---@return string[]
local function generate_factories(schema, namespace)
  local out_lines = {}
  local function emit(line)
    table.insert(out_lines, line)
  end
  local function emitf(fmt, ...)
    emit(string.format(fmt, ...))
  end

  emit("--")
  emit("-- GENERATED BY rc.toys.doxygen.generator.lua")
  emit("--")
  emit("local factory = {}")

  emit("--- @param builder eeeBuilder")
  emit("--- @return string")
  emit("function factory.string(builder)")
  emit("  return builder:from_text()")
  emit("end")
  emit("")

  emit("--------------------------------")
  emit("-- Complex Types")
  emit("--------------------------------")
  for _, complex_type in ipairs(schema.complex_types) do
    emitf("--- @param builder eeeBuilder")
    emitf("--- @return %s.%s", namespace, complex_type.name)
    emitf("function factory.%s(builder)", complex_type.name)
    emitf("  return{ --- @type %s.%s", namespace, complex_type.name)
    if complex_type.mixed then
      emitf("    %s = builder:from_element_mixed(),", "content") -- TODO
      for _, current in ipairs(complex_type.content) do
        if current.kind == "attribute" then
          local type = t(current.type)
          local basetypes = {
            boolean = "boolean",
            string = "string",
            number = "number",
            integer = "number",
          }

          emitf(
            '    ["%s"] = builder:from_attr("%s","%s","%s"),',
            v(current.name),
            current.name,
            current.occurs,
            basetypes[type] and basetypes[type] or find_simple_type(schema, current.type).base
          )
        end
      end
    else
      emit(generate_content_fields(schema, complex_type))
    end
    emitf("  }")
    emitf("end")
    emit("")
  end

  emit("--------------------------------")
  emit("-- Groups")
  emit("--------------------------------")
  for _, group in ipairs(schema.groups) do
    emitf("--- @param builder eeeBuilder")
    emitf("--- @return %s.%s", namespace, group.name)
    emitf("function factory.%s(builder)", group.name)
    emitf("  return{ --- @type %s.%s", namespace, group.name)
    emit(generate_content_fields(schema, group))
    emitf("  }")
    emitf("end")
  end

  emit("return factory")
  return out_lines
end

-- Load XSD schema
local function generate_file(input_filename, output_filename, namespace)
  local file = assert(io.open(input_filename, "r"))
  local json_str = file:read("*all")
  file:close()

  ---@type XmlElement
  local root = vim.json.decode(json_str)
  if not root then
    error("JSON decode error")
  end

  local schema = require("rc.toys.doxygen.generator.util").xsd_build_schema(root)
  require("rc.toys.doxygen.util").dump_json(schema, "schema.json", true)

  -- Generate types and write to file
  local out_lines = generate_factories(schema, namespace)
  local outfile = assert(io.open(output_filename, "w"))
  outfile:write(table.concat(out_lines, "\n"))
  outfile:close()
end

generate_file(
  vim.fs.normalize("~/.cache/nvim/doxygen-index.xsd.json"),
  vim.fs.normalize(vim.fs.joinpath(get_script_path(), "../factory/index.lua")),
  "doxygen.index"
)

generate_file(
  vim.fs.normalize("~/.cache/nvim/doxygen-compound.xsd.json"),
  vim.fs.normalize(vim.fs.joinpath(get_script_path(), "../factory/compound.lua")),
  "doxygen.compound"
)
